
如果多运行几次或者将测试类中的循环次数改大，则会发现出现死锁的概率还是很高的。下面分析发生这种问题的原因：
在jdk中对于Object.wait有这样的一段解释：
当前线程必须拥有此对象监视器。该线程放弃对此监视器的所有权并等待，
直到其他线程通过调用notify方法或notifyAll方法通知在此对象的监视器上等待的线程醒来。
可见下面一种情况就可能出现：消费者1进入等待状态（此时资源锁已被放开），
如果此时消费者2获取到了资源同步锁（没有人保证消费者1进入等待，下一个拿到锁的一定是生产者），
消费者2判断没有资源也进入等待状态；此时生产者1生产了，并notify了消费者1，消费者1顺利地消费了，
并执行notify操作，但此时消费者2却也因为资源而处于等待状态，从而唤醒了消费者2（消费者1本欲唤醒其他生产者），
而此时并没有任何资源，导致了整个程序因为消费者2陷入无限的等待，形成了死锁。
经过以上分析，究其根本原因是：同时几个消费者或几个生产者处于等待状态，导致消费者可能唤醒的还是消费者，
或者生产者唤醒的还是生产者。那么如果我们能够保证同时只有一个消费者处于wait状态（生产者同理），
那就就能保证消费者唤醒的一定是生产者，从而能使整个任务顺利进行下去。
